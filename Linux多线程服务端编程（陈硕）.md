# Linux多线程服务端编程（陈硕）

## 第一章：线程安全的对象声明周期

```html
1、一个线程安全的 class 应当满足：
    1.1、多个线程同时访问时，其表现出正确的行为。无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织（ interleaving）。
    1.2、调用端代码无须额外的同步或其他协调动作。
2、线程安全的对象构造方法
    2.1、不要在构造函数中注册任何回调函数。
    2.2、不要在构造函数中把 this 传递给跨线程的对象。
    2.3、采用二段式构造：构造函数+ initialize。
3、作为数据成员的 mutex 不能保护析构，因为析构有可能销毁 mutex 本身，而此时析构却还没全部完成。
4、三种对象关系的多线程安全性
    4.1、组合（composition）：很明晰。它们的生命期都由其拥有者控制，是一致的，不会有什么问题。
    4.2、关联（association）：只有另一个对象的指针或引用，无法知道其是生是死。判断指针是否合法在 C++ 中没有高效的方法。
    4.3、聚合（aggregation）：其困难和关联类似。虽然是整体和部分的关系，但这个“部分”的生命期受外部影响。
5、Observer 设计模式中，多个 Observer 的指针（引用）注册到 Observable，这些指针的使用可能引发 race condition。
6、C++  内存问题及对策
    6.1、缓冲区溢出 buffer overrun：使用 vector<char> 、string 或者自己编写的 Buffer class 管理内存。
    6.2、空悬指针/野指针：使用 shared_ptr/weak_ptr。
    6.3、重复释放 double delete：使用 scoped_ptr。
    6.4、内存泄露 memory leak：使用 scoped_ptr。
    6.5、不配对的 new[]/delete：把 new[] 替换为 vector/scoped_array。
    6.6、内存碎片 memory fragementation。
7、shared_ptr/weak_ptr
    7.1、shared_ptr 控制对象的生命周期。
        7.1.1、注意，如果 shared_ptr 的一个拷贝在某个地方长期被持有，其管理的对象就一直没有被析构。这可能会意外延长了对象的生命期。
        7.1.2、避免拷贝的性能损耗：一个线程只需在最外层函数持有一个实体对象，之后都可以使用 const reference 来使用这个 shared_ptr 对象。
    7.2、weak_ptr 不控制对象的生命期，但是它知道对象是否还活着。
8、使用单独的线程做 shared_ptr 管理的对象的析构，避免耗时的析构发生在关键线程里。
9、RAII（资源获取即初始化）。每一个明确的资源配置动作（例如 new）都应该在单一语句中执行，并在该语句中立刻将配置获得的资源交给 handle 对象（如 shared_ptr），程序中一般不出现 delete。
```

## 第二章： 线程同步精要

```html
1、并发编程基本模型：message passing、shared memory。
2、线程同步的四项原则
    2.1、尽量最低限度地共享对象，减少需要同步的场合。如果确实需要，优先考虑共享 immutable 对象。
    2.2、使用高级的并发编程构件。
    2.3、不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。
    2.4、除了使用 atomic 整数之外，不自己编写 lock-free 代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如 spin lock vs. mutex。
3、互斥器（mutex）使用原则：
    3.1、用 RAII 手法封装 mutex 的创建、销毁、加锁、解锁这四个操作。保证锁的生效期间等于一个作用域（scope）。
    3.2、只用非递归的 mutex（即不可重入的 mutex）。
    3.3、不手工调用 lock() 和 unlock() 函数，一切交给栈上的 Guard 对象的构造和析构函数负责（Scoped Locking）。
    3.4、在每次构造 Guard 对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁。
4、条件变量 - 学名为管程（monitor）
    4.1、对于 wait() 端：
        4.1.1、必须与 mutex 一起使用，该布尔表达式的读写需受此 mutex 的保护。
        4.1.2、在 mutex 已上锁的情况下才能调用 wait()。
        4.1.3、把判断布尔表达式和 wait() 放在 while 循环中。
    4.2、对于 signal/broadcast 端：
        4.2.1、不一定要在 mutex 已上锁的情况下调用 signal（理论上）。
        4.2.2、在 signal 之前一般要修改布尔表达式。
        4.2.3、修改布尔表达式通常需要用 mutex 保护（至少用作 full memory barrier）。
        4.2.4、broadcast 通常用于表明状态变化，signal 通常用于表示资源可用。
    4.3、虚假唤醒（spurious wakeup），Linux 中 futex 慢速系统调用被信号打断返回 -1，wait 返回了。
5、使用非递归 mutex 使得调试死锁错误更容易。
6、使用 mutex 代替 rwlock。
7、使用 pthread_once 实现线程安全的 Singleton。
8、sleep()/usleep()/nanosleep() 只能出现在测试代码中。比如写单元测试的时候，或者用于有意延长临界区，加速复现死锁的情况。
```

## 第三章： 多线程服务器的适用常用编程模型

```
1、单线程服务器常用的编程模型
    non-blocking IO + IO multiplexing（reactor 模式，事件驱动）
2、使用 Reactor 模式的网络程序
    2.1、lighttpd
    2.2、libevent，libev
    2.3、ACE，Poco C++ Libraries
    2.4、Java NIO（Apache Mina，Netty）
    2.5、POE（Perl）
    2.6、Twisted（Python）
3、多线程服务器常用的编程模型
    3.1、每个请求创建一个线程，使用非阻塞式 IO 操作。
    3.2、使用线程池，同样使用非阻塞式 IO 操作。
    3.3、使用 non-blocking IO + IO multiplexing。
    3.4、Leader/Follower 等高级模式。
4、one loop per thread + thread pool。
    4.1、event loop 用作 IO multiplexing。
    4.2、thread pool 用来做计算。
5、进程间通信只用 TCP。
    跨主机，具有伸缩性。
6、单线程程序
    6.1、必须使用的场合：
        6.1.1、程序可能会 fork(2)。
        6.1.2、要限制程序的 CPU 占用率。
    6.2、优点：简单。
    6.3、缺点：非抢占，可能发生优先级反转。
7、适用多线程程序的场景：
    7.1、有多个 CPU 可用。
    7.2、线程间有共享的可编辑的数据。
    7.3、提供非均质服务，例如具有不同优先级。
    7.4、latency 和 throughput 同样重要，不是逻辑简单的 IO bound 或者 CPU bound 程序。
    7.5、异步操作。
    7.6、scale up，可以享受增加 CPU 带来的好处。
    7.7、具有可预测的性能。
    7.8、有效地划分责任和功能。
8、多线程服务程序的线程分类
    8.1、IO 线程。
    8.2、计算线程。
    8.3、第三方库线程。
9、线程池的阻抗匹配原则
    考虑密集计算占 CPU 时间的比重以及 CPU 总数，得出最恰当的线程数，使得所有 CPU 刚好满载。太多反而会以为进程调度降低性能。
```

## 第四章 C++多线程系统编程精要

```
1、执行顺序的不确定性。
    1.1、11 个最基本的 Pthreads 函数：
    1.2、2 个：线程的创建和等待结束。
    1.3、4 个：mutex 的创建、销毁、加锁、解锁。
    1.4、5 个：条件变量的创建、销毁、等待、通知、广播。
2、尽管单个函数是线程安全的，但两个或多个函数放到一起就不再安全了。
3、pthread_t 并不适合用作程序中对线程的标识符。在 Linux 上，使用 gettid(2) 系统调用的返回值作为线程 id。
4、线程创建原则：
    4.1、程序库不应该在未提前告知的情况下创建自己的“背景线程”。
    4.2、尽量用相同的方式创建线程。
    4.3、进入 main() 函数之前不应该启动线程。
    4.4、程序中线程的创建最好能在初始化阶段全部完成。
5、线程的销毁方式：
    5.1、自然死亡。从线程主函数返回，线程正常退出。
    5.2、非正常死亡。抛出异常或者触发致命信号。
    5.3、自杀。自己调用 pthread_exit() 即刻退出。
    5.4、他杀。其他线程调用 pthread_cancle()。
    5.5、线程正常退出的方式只有一种，即自然死亡。
6、每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种 race condition。一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符。
7、一个线程可以操作多个文件描述符，但不能操作别的线程已经拥有的文件描述符。
8、RAII 技法与 fork() 的冲突。
9、多线程与 fork() 的冲突。
10、多线程与 signal(Linux/UNIX 信号) 的冲突。
11、多线程 C++ 程序编写原则：
    11.1、线程是宝贵的。一个程序可以使用几个或几十个线程，但一台机器上不应该同时运行几百个、几千个线程。
    11.2、线程的创建和销毁是有代价的。最好一开始就创建所需线程并反复使用。
    11.3、每个线程应该有明确的职责。例如 IO 线程或计算线程。
    11.4、线程之间的交互应该尽量简单。
    11.5、考虑清楚一个 mutable shared 对象将会暴露给哪些线程，每个线程是读还是写，是否并发。
```

## 第五章 高效的多线程日志

```html
1、两种日志：诊断日志和交易日志
2、关键进程记录的日志
    2.1、收到的每条内部消息的 ID、关键字段、长度、hash 值等。
    2.2、收到的每条外部消息的全文。
    2.3、发出的每条消息的全文。
    2.4、关键内部状态变更。
3、一个日志库大致分为：前端 - 生成日志；后端 - 把日志写到目的地。异步日志。
4、日志库应该提供的基本功能：
    4.1、日志消息有多种级别（level）。（必需的功能）。
    4.2、日志消息可能有多个目的地（appender），文件、socket、STMP 等。
    4.3、日志消息的格式可配置（layout）。
5、日志消息的几个要点
    5.1、尽量每条日志占一行，方便分析。
    5.2、时间戳精确到微秒，是用 gettimeofday()。
    5.3、使用 GMT 时区。
    5.4、打印线程 id。
    5.5、打印日志级别。
    5.6、打印原文件名和行号。
6、muduo 日志库采用的双缓冲（double buffering）技术。
    基本思路是准备两块 buffer：A 和 B，前端负责往 buffer A 填写数据，后端负责将 buffer B 的数据写入文件。buffer A 写满就交换 A 和 B。如此往复。
```

## 第六章 muduo网络库简介

```
1、muduo 是基于 Reactor 模式的网络库，其核心是个事件循环 EventLoop，用于响应计时器和 IO 事件。
2、muduo 采用基于对象（object- based）而非面向对象（ objectoriented）的设计风格，其事件回调接口多以 boost:: function＋boost:: bind 表达，用户在使用 muduo 的时候不需要继承其中的 class。
3、muduo 的线程模型：
one loop per thread + thread pool 模型。
4、TCP 网络编程最本质的三个半事件：
    4.1、连接的建立。服务端接受（accept），客户端成功发起（connect）。
    4.2、连接的断开。主动断开和被动断开。
    4.3、消息到达。文件描述符可读。
    4.4、消息发送完毕，这算半个。
5、常见的并发网络服务程序设计方案
    5.0、accept + read/write
    5.1、accept + fork
    5.2、accept + thread（实用）
    5.3、prefork
    5.4、pre threaded
    5.5、poll(reactor)（实用）
    5.6、reactor + thread-per-task
    5.7、reactor + worker thread
    5.8、reactor + thread pool（实用）
    5.9、reactors in threads（实用）
    5.10、reactors in processes
    5.11、reactors + thread pool（实用）
```

## 第九章 分布式系统工程实践

```
1、分布式系统的本质困难 - partial failure。
    1.1、分布式系统与单机的最大区别，是我们无法及时得知另外一台机器的死活，也无法把机器崩溃和网络故障区分开来。
    1.2、分布式系统的困难还在于时间与事件顺序违反直觉。因为消息传递有延时而且不固定，这就好像狭义相对论的效果，每个本地观察者有自己的时钟和时间顺序。
    1.2消息传输的延迟不能通过发送方和接收方的时间戳的差值算出来。即使使用 NTP 对时，精度还是不够。
2、可靠性 Reliability = exp( - t / t<MTBF> )、可用性 = t<MTBF> / ( t<MTBF> + t<MTTR> )
    2.1、平均无故障运行时间 - MTBF（Mean Time Between Failure）
    2.平均修复时间 - MTTR（Mean Time to Recovery）
    2.高可用的关键不在于做到不停机，恰恰相反，要做到能随时重启任何一个进程或者服务。这就要求程序只使用操作系统能自动回收的 IPC，生命期不大于进程的 IPC，可以重建的 IPC。也就是，只是用 TCP 来进行进程间通信。
3、心跳协议。
    3.1、一般是 C 依赖 S，S 以固定周期向 C 发送心跳，C 按固定周期检查心跳。
    3.2、心跳要在工作线程发送，不要专门起一个线程来发送。
    3.3、心跳消息与业务消息使用同一个连接。
4、使用四元组标识进程：ip:port:start_time:pid。
5、分布式系统中每个长期运行的、会与其他机器打交道的的进程都应该提供一个管理接口，对外提供一个维修探查通道，可以查看甚至更改进程的全部状态。
6、以单独的进程作为 test harness 对于开发分布式程序相当有帮助，它能达到单元测试的自动化程度和细致程度，又避免了单元测试对功能代码结构的侵入和依赖。
```

## 第七章 muduo编程实例

```
1、简单的 TCP 示例
    1.1、discard，daytime，time，echo，chargen。
2、文件传输，利用 onWriteComplete() 实现分段传输，做到不必一次全部读入内存。
3、TCP haft-close 问题。
4、TCP 消息分包方法：
    4.1、消息长度固定。
    4.2、使用特殊字符或字符串作为消息边界。
    4.3、在每条消息头部加一个长度字段。
    4.4、利用消息本身的格式分包，例如 XML、JSON。
5、muduo Buffer 类的设计与使用
    5.1、non-blocking IO 的核心思想是避免阻塞在 read() 或 write() 或其他 IO 系统调用上，这样可以最大限度地复用 thread-of-control ，让一个线程能够服务于多个 socket 连接。这就是需要应用层 buffer 的原因。
    5.2、muduo::net::Buffer 的实现不是线程安全的。
    5.3、Buffer 类内部使用 std::vector<char> 存储数据。大小自增长，使用了 vector 的 capicity 特性。
6、muduo 与 Google Protobuf
7、时间相关任务
    7.1、与时间有关的常见任务
        7.1.1、获取当前时间、计算时间间隔。
        7.1.2、时区转换与日期计算。
        7.1.3、定时操作。
    7.2、muduo 使用的时间操作函数
        7.2.1、计时：只使用 gettimeofday(2) 获取当前时间。
        7.2.2、定时：只使用 timerfd_* 系列函数。
    7.3、在非阻塞服务端编程中，绝对不能用 sleep() 或类似的办法来让程序原地等待，这会让主事件循环被挂起，程序失去响应。
8、测量两台机器的网络延迟与时间差。
```

